#include "Solver.h"
//посылка, передвинься в контейнер
void Solver::parcel_to_container(vector<Container> *container_mass, vector<Parcel> parcel_mass, int num_parcel, int* num_container)
{
	for (int i = 0; i < num_parcel; i++)
	{
		cout << "На данный момент контейнеров: " << container_mass->size();
		cout << "Распределение начинаем!!!\n";
		if (parcel_mass[i].danger == 1)		//распределение опасной посылки
		{
			Container* container_temp = new danger_cont();		

			container_temp->generate_id();
			container_temp->get_parcel(parcel_mass[i]);
			container_mass->push_back(*container_temp);
			*num_container = *num_container + 1;
			
			/*
			cout << parcel_mass[i].danger;		//вывод флажка контейнера
			_getch();
			*/
		}
		else
		{
			if (container_mass.size() > 0)	//если уже есть контейнеры
			{
				//проверка наличия свободного места к существующих контейнерах
				for (int j = 0; j < *num_container; j++)
				{
					if (container_mass[j].check_free_obem(parcel_mass[i].obem) > 0)
					{
						//проверка города направления
						if (container_mass[j].get_town() == parcel_mass[i].get_town())
						{
							//container_mass[j]->set_parcel_minus();
							container_mass[j].get_parcel(parcel_mass[i]);	//добавление 
						}
						else     //если контейнер для отправления в данный город еще не был создан/оформлен
						{
							goto new_cont;		//создание нового контейнера
						}
					}
					else    //переход к созданию нового контейнера
					{
						goto new_cont;
					}
				}
			}
			else    //создание нового контейнера
			{
				new_cont:
				Container* container_temp = new big_cont();

				container_temp->generate_id();
				container_temp->get_parcel(parcel_mass[i]);
				container_mass.push_back(*container_temp);
				*num_container = *num_container + 1;
			}
		}
	}
}




